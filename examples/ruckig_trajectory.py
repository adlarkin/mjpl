'''
Example of how to generate a trajectory from a path generated by RRT.
The trajectory generation is done by ruckig: https://ruckig.com/
'''

import mujoco
import mujoco.viewer
import numpy as np
import time
from dataclasses import dataclass
from pathlib import Path
from ruckig import InputParameter, OutputParameter, Result, Ruckig
from scipy.interpolate import make_interp_spline

from mj_maniPlan.rrt import (
    RRT,
    RRTOptions,
)
import mj_maniPlan.utils as utils
import mj_maniPlan.visualization as viz


_HERE = Path(__file__).parent
_PANDA_XML = _HERE.parent / "models" / "franka_emika_panda" / "scene.xml"

_EE_SITE = 'ee_site'


# Naive timing generation for a path, which can be used for something like B-spline interpolation.
# Configuration distance between two adjacent path waypoints - q_curr, q_next - is used as a notion
# for the time it takes to move from q_curr to q_next.
def generate_path_timing(path):
    timing = [0.0]
    for i in range(1, len(path)):
        timing.append(timing[-1] + utils.configuration_distance(path[i-1], path[i]))
    # scale to [0..1]
    return np.interp(timing, (timing[0], timing[-1]), (0, 1))

def update_joint_config(q: np.ndarray, qpos_addrs, model: mujoco.MjModel, data: mujoco.MjData):
    data.qpos[qpos_addrs] = q
    mujoco.mj_kinematics(model, data)

# Trajectory data for a list of waypoints.
# n = the number of configurations, velocities, and accelerations.
# The duration of the trajectory is dt * n.
@dataclass
class Trajectory:
    # The timestep between each configuration, velocity, and acceleration.
    dt: float
    # Configuration snapshots at increments of dt, ranging from t = [dt, t_f].
    # Each configuration snapshot size is mjData.qpos
    configurations: list[list[float]]
    # Velocity snapshots at increments of dt, ranging from t = [dt, t_f]
    # Each velocity snapshot size is mjData.qvel
    velocities: list[list[float]]
    # Acceleration snapshots at increments of dt, ranging from t = [dt, t_f]
    # Each acceleration size is mjData.qacc
    accelerations: list[list[float]]

def generate_trajectory(dof, ctrl_cycle_rate, path) -> Trajectory:
    otg = Ruckig(dof, ctrl_cycle_rate, len(path))
    inp = InputParameter(dof)
    out = OutputParameter(dof, len(path))

    inp.current_position = path[0]
    inp.current_velocity = np.zeros(dof)
    inp.current_acceleration = np.zeros(dof)

    inp.intermediate_positions = path[1:-1]

    inp.target_position = path[-1]
    inp.target_velocity = np.zeros(dof)
    inp.target_acceleration = np.zeros(dof)

    # TODO: query mj_model for this info?
    inp.max_velocity = np.ones(dof) * np.pi
    inp.max_acceleration = np.ones(dof) * np.pi
    inp.max_jerk = np.ones(dof) * np.pi

    # TODO: Pre-process the input path by filtering out some of the waypoints?
    # For more info, see https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html

    configs = []
    vels = []
    accels = []
    traj_duration = None
    res = Result.Working
    while res == Result.Working:
        res = otg.update(inp, out)
        configs.append(out.new_position)
        vels.append(out.new_velocity)
        accels.append(out.new_acceleration)
        if not traj_duration:
            traj_duration = out.trajectory.duration
        out.pass_to_input(inp)
    if res != Result.Finished:
        print("Did not successfully complete trajectory generation (this should not happen!)")

    return Trajectory(ctrl_cycle_rate, configs, vels, accels)


if __name__ == '__main__':
    model = mujoco.MjModel.from_xml_path(_PANDA_XML.as_posix())
    data = mujoco.MjData(model)

    # The joints to sample during planning.
    # Since this example executes planning for the arm,
    # the finger joints of the gripper are excluded.
    joint_names = [
        'joint1',
        'joint2',
        'joint3',
        'joint4',
        'joint5',
        'joint6',
        'joint7',
    ]

    # Random number generator that's used for sampling joint configurations.
    rng = np.random.default_rng(seed=5)

    joint_qpos_addrs = utils.joint_names_to_qpos_addrs(joint_names, model)

    # Use the model's `home` configuration as the initial configuration.
    mujoco.mj_resetDataKeyframe(model, data, model.key('home').id)
    q_init = data.qpos[joint_qpos_addrs]

    # Generate a valid goal configuration.
    lower_limits, upper_limits = utils.joint_limits(joint_names, model)
    q_goal = utils.random_valid_config(rng, lower_limits, upper_limits, joint_qpos_addrs, model, data)

    # Set up the planner.
    # Tweak the values in planner_options to see the effect on generated plans!
    epsilon = 0.05
    planner_options = RRTOptions(
        joint_names=joint_names,
        max_planning_time=10,
        epsilon=epsilon,
        shortcut_filler_epsilon=10*epsilon,
        rng=rng,
        goal_biasing_probability=0.1,
    )
    # The state of MjData passed to the RRT object is used as the initial planning state.
    # random_valid_config modifies MjData in place, so we reset MjData to match q_init before
    # constructing the RRT object.
    update_joint_config(q_init, joint_qpos_addrs, model, data)
    planner = RRT(planner_options, model, data)

    print("Planning...")
    start = time.time()
    path = planner.plan(q_goal)
    if not path:
        print("Planning failed")
        exit()
    print(f"Planning took {time.time() - start}s")

    print("Shortcutting...")
    start = time.time()
    shortcut_path = planner.shortcut(path, num_attempts=len(path))
    print(f"Shortcutting took {time.time() - start}s")
    print(f"Path length: {len(path)}, shortcut path length: {len(shortcut_path)}")

    # Smooth the path by performing naive joint-space B-spline interpolation.
    spline_shortcut = make_interp_spline(generate_path_timing(shortcut_path), shortcut_path)

    print("Generating a trajectory on the shortcut path...")
    start = time.time()
    traj = generate_trajectory(len(joint_names), model.opt.timestep, shortcut_path)
    print(f"Trajectory generation took {time.time() - start}s")

    with mujoco.viewer.launch_passive(model=model, data=data, show_left_ui=False, show_right_ui=False) as viewer:
        # Update the viewer's orientation to capture the scene.
        viewer.cam.lookat = [0, 0, 0.35]
        viewer.cam.distance = 2.5
        viewer.cam.azimuth = 145
        viewer.cam.elevation = -25

        # Show the initial EE pose
        update_joint_config(q_init, joint_qpos_addrs, model, data)
        init_pos = data.site(_EE_SITE).xpos
        init_rot = data.site(_EE_SITE).xmat.reshape(3,3)
        viz.add_frame(viewer.user_scn, init_pos, init_rot)

        # Show the target EE pose
        update_joint_config(q_goal, joint_qpos_addrs, model, data)
        target_pos = data.site(_EE_SITE).xpos
        target_rot = data.site(_EE_SITE).xmat.reshape(3,3)
        viz.add_frame(viewer.user_scn, target_pos, target_rot)

        # Show the shortcut path.
        path_rgba = [0.2, 0.6, 0.2, 0.2]
        horizon = np.linspace(0, 1, 1000)
        for t in horizon:
            q_t = spline_shortcut(t)
            update_joint_config(q_t, joint_qpos_addrs, model, data)
            ee_world_pos = data.site(_EE_SITE).xpos
            viz.add_sphere(viewer.user_scn, ee_world_pos, 0.003, path_rgba)

        # Ensure the robot is at q_init and then update the viewer to show
        # the frames, paths, and initial state.
        update_joint_config(q_init, joint_qpos_addrs, model, data)
        viewer.sync()

        # Command the robot along the path via computed torque control.
        while viewer.is_running():
            time.sleep(0.5)

            # Reset sim to initial state
            mujoco.mj_resetDataKeyframe(model, data, model.key('home').id)
            mujoco.mj_forward(model, data)

            for t in range(len(traj.configurations)):
                start_time = time.time()

                data.ctrl[joint_qpos_addrs] = traj.configurations[t]
                mujoco.mj_step(model, data)

                duration = time.time() - start_time
                if duration < traj.dt:
                    time.sleep(traj.dt - duration)
                viewer.sync()
